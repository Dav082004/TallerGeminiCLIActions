# =============================================================
# WORKFLOW: Gemini CLI - Asistente General Inteligente
# =============================================================
# Este workflow proporciona un asistente de IA que puede:
# - ü§ñ Responder preguntas sobre c√≥digo y proyectos
# - üîß Crear fixes autom√°ticos para issues
# - üí¨ Responder comentarios en PRs
# - üìù Modificar c√≥digo y documentaci√≥n autom√°ticamente
# - üöÄ Crear branches y pull requests autom√°ticamente
#
# ACTIVACI√ìN: Cuando se menciona @gemini-cli (sin /triage o /review)
# PERMISOS: contents:write, issues:write, pull-requests:write
# SEGURIDAD: Solo usuarios de confianza (OWNER, MEMBER, COLLABORATOR)
# =============================================================

name: 'üí¨ Gemini CLI Assistant'

# EVENTOS QUE ACTIVAN EL WORKFLOW
on:
  pull_request_review_comment:    # Comentarios en revisiones de PR
    types:
      - 'created'
  pull_request_review:            # Reviews completados en PRs
    types:
      - 'submitted'
  issue_comment:                  # Comentarios en issues y PRs
    types:
      - 'created'

# CONTROL DE CONCURRENCIA
# Evita m√∫ltiples ejecuciones simult√°neas en el mismo issue/PR
concurrency:
  group: '${{ github.workflow }}-${{ github.event.issue.number }}'
  cancel-in-progress: |-
    ${{ github.event.sender.type == 'User' && ( github.event.issue.author_association == 'OWNER' || github.event.issue.author_association == 'MEMBER' || github.event.issue.author_association == 'COLLABORATOR') }}

# CONFIGURACI√ìN PREDETERMINADA
defaults:
  run:
    shell: 'bash'    # Usar bash para todos los comandos shell

# PERMISOS NECESARIOS PARA EL WORKFLOW
permissions:
  contents: 'write'        # üìù NECESARIO: Para modificar archivos y hacer commits
  id-token: 'write'        # üîê Para autenticaci√≥n con Google Cloud (si se usa)
  pull-requests: 'write'   # üîÑ NECESARIO: Para comentar y crear PRs
  issues: 'write'          # üí¨ NECESARIO: Para comentar en issues

jobs:
  gemini-cli:
    # =================================================================
    # CONDICIONES DE SEGURIDAD Y ACTIVACI√ìN
    # =================================================================
    # Este workflow SOLO se ejecuta cuando:
    # 1. Es activado manualmente (workflow_dispatch)
    # 2. Se menciona @gemini-cli en issues/comentarios/reviews
    # 3. NO incluye comandos espec√≠ficos (/review, /triage)
    # 4. El usuario es de CONFIANZA (OWNER, MEMBER, COLLABORATOR)
    # 
    # SEGURIDAD: En repos p√∫blicos, solo usuarios con permisos pueden activar
    # PRIVADOS: Cualquier usuario con acceso puede activar
    # =================================================================
    if: |-
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'issues' && github.event.action == 'opened' &&
        contains(github.event.issue.body, '@gemini-cli') &&
        !contains(github.event.issue.body, '@gemini-cli /review') &&
        !contains(github.event.issue.body, '@gemini-cli /triage') &&
        (
          github.event.repository.private == true ||
          contains(fromJSON('["OWNER", "MEMBER", "COLLABORATOR"]'), github.event.issue.author_association)
        )
      ) ||
      (
        (
          github.event_name == 'issue_comment' ||
          github.event_name == 'pull_request_review_comment'
        ) &&
        contains(github.event.comment.body, '@gemini-cli') &&
        !contains(github.event.comment.body, '@gemini-cli /review') &&
        !contains(github.event.comment.body, '@gemini-cli /triage') &&
        (
          github.event.repository.private == true ||
          contains(fromJSON('["OWNER", "MEMBER", "COLLABORATOR"]'), github.event.comment.author_association)
        )
      ) ||
      (
        github.event_name == 'pull_request_review' &&
        contains(github.event.review.body, '@gemini-cli') &&
        !contains(github.event.review.body, '@gemini-cli /review') &&
        !contains(github.event.review.body, '@gemini-cli /triage') &&
        (
          github.event.repository.private == true ||
          contains(fromJSON('["OWNER", "MEMBER", "COLLABORATOR"]'), github.event.review.author_association)
        )
      )
    timeout-minutes: 10    # ‚è±Ô∏è Timeout de 10 minutos para evitar ejecuciones largas
    runs-on: 'ubuntu-latest'
    steps:
      # =================================================================
      # PASO 1: GENERAR TOKEN DE GITHUB APP (OPCIONAL)
      # =================================================================
      # Si se configura una GitHub App personalizada, genera un token
      # Ventajas: Mayor l√≠mite de rate, mejor seguridad
      # Alternativa: Usar GITHUB_TOKEN predeterminado
      # =================================================================
      - name: 'üîê Generar Token de GitHub App'
        id: 'generate_token'
        if: |-
          ${{ vars.APP_ID }}
        uses: 'actions/create-github-app-token@a8d616148505b5069dccd32f177bb87d7f39123b' # ratchet:actions/create-github-app-token@v2
        with:
          app-id: '${{ vars.APP_ID }}'
          private-key: '${{ secrets.APP_PRIVATE_KEY }}'

      # =================================================================
      # PASO 2: EXTRAER CONTEXTO DEL EVENTO
      # =================================================================
      # Identifica el tipo de evento y extrae:
      # - USER_REQUEST: El comentario/contenido del usuario
      # - ISSUE_NUMBER: N√∫mero del issue o PR
      # - IS_PR: Si es un Pull Request (true/false)
      # =================================================================
      - name: 'üìã Obtener contexto del evento'
        id: 'get_context'
        env:
          EVENT_NAME: '${{ github.event_name }}'
          EVENT_PAYLOAD: '${{ toJSON(github.event) }}'
        run: |-
          set -euo pipefail

          USER_REQUEST=""
          ISSUE_NUMBER=""
          IS_PR="false"

          if [[ "${EVENT_NAME}" == "issues" ]]; then
            USER_REQUEST=$(echo "${EVENT_PAYLOAD}" | jq -r .issue.body)
            ISSUE_NUMBER=$(echo "${EVENT_PAYLOAD}" | jq -r .issue.number)
          elif [[ "${EVENT_NAME}" == "issue_comment" ]]; then
            USER_REQUEST=$(echo "${EVENT_PAYLOAD}" | jq -r .comment.body)
            ISSUE_NUMBER=$(echo "${EVENT_PAYLOAD}" | jq -r .issue.number)
            if [[ $(echo "${EVENT_PAYLOAD}" | jq -r .issue.pull_request) != "null" ]]; then
              IS_PR="true"
            fi
          elif [[ "${EVENT_NAME}" == "pull_request_review" ]]; then
            USER_REQUEST=$(echo "${EVENT_PAYLOAD}" | jq -r .review.body)
            ISSUE_NUMBER=$(echo "${EVENT_PAYLOAD}" | jq -r .pull_request.number)
            IS_PR="true"
          elif [[ "${EVENT_NAME}" == "pull_request_review_comment" ]]; then
            USER_REQUEST=$(echo "${EVENT_PAYLOAD}" | jq -r .comment.body)
            ISSUE_NUMBER=$(echo "${EVENT_PAYLOAD}" | jq -r .pull_request.number)
            IS_PR="true"
          fi

          # Clean up user request
          USER_REQUEST=$(echo "${USER_REQUEST}" | sed 's/.*@gemini-cli//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

          {
            echo "user_request=${USER_REQUEST}"
            echo "issue_number=${ISSUE_NUMBER}"
            echo "is_pr=${IS_PR}"
          } >> "${GITHUB_OUTPUT}"

      # =================================================================
      # PASO 3: CONFIGURAR GIT PARA COMMITS AUTOM√ÅTICOS
      # =================================================================
      # Configura la identidad de git para que Gemini pueda hacer commits
      # autom√°ticamente cuando modifique archivos o cree fixes
      # =================================================================
      - name: 'üîß Configurar usuario git para commits'
        run: |-
          git config --global user.name 'gemini-cli[bot]'
          git config --global user.email 'gemini-cli[bot]@users.noreply.github.com'

      # =================================================================
      # PASO 4: CHECKOUT DE BRANCH DEL PR (SI APLICA)
      # =================================================================
      # Si la solicitud viene de un PR, hace checkout del branch del PR
      # Esto permite que Gemini modifique el c√≥digo directamente en el PR
      # =================================================================
      - name: 'üì• Checkout branch del PR'
        if: |-
          ${{  steps.get_context.outputs.is_pr == 'true' }}
        uses: 'actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8' # ratchet:actions/checkout@v5
        with:
          token: '${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          repository: '${{ github.repository }}'
          ref: 'refs/pull/${{ steps.get_context.outputs.issue_number }}/head'
          fetch-depth: 0

      # =================================================================
      # PASO 5: CHECKOUT DE BRANCH PRINCIPAL (SI NO ES PR)
      # =================================================================
      # Para issues normales, hace checkout del branch principal
      # Gemini crear√° un nuevo branch para sus cambios
      # =================================================================
      - name: 'üì• Checkout branch principal'
        if: |-
          ${{  steps.get_context.outputs.is_pr == 'false' }}
        uses: 'actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8' # ratchet:actions/checkout@v5
        with:
          token: '${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          repository: '${{ github.repository }}'
          fetch-depth: 0

      # =================================================================
      # PASO 6: NOTIFICACI√ìN DE CONFIRMACI√ìN
      # =================================================================
      # Confirma al usuario que se recibi√≥ la solicitud y se est√° procesando
      # Proporciona feedback inmediato para mejorar la experiencia del usuario
      # =================================================================
      - name: 'üí¨ Confirmar recepci√≥n de solicitud'
        env:
          GITHUB_ACTOR: '${{ github.actor }}'
          GITHUB_TOKEN: '${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          ISSUE_NUMBER: '${{ steps.get_context.outputs.issue_number }}'
          REPOSITORY: '${{ github.repository }}'
          REQUEST_TYPE: '${{ steps.get_context.outputs.request_type }}'
        run: |-
          set -euo pipefail
          MESSAGE="@${GITHUB_ACTOR} ¬°He recibido tu solicitud y estoy trabajando en ella ahora! ü§ñ"
          if [[ -n "${MESSAGE}" ]]; then
            gh issue comment "${ISSUE_NUMBER}" \
              --body "${MESSAGE}" \
              --repo "${REPOSITORY}"
          fi

      # =================================================================
      # PASO 7: OBTENER DESCRIPCI√ìN DEL ISSUE/PR
      # =================================================================
      # Extrae la descripci√≥n del issue o PR para proporcionar contexto
      # completo a Gemini sobre el problema o solicitud original
      # =================================================================
      - name: 'üìÑ Obtener descripci√≥n'
        id: 'get_description'
        env:
          GITHUB_TOKEN: '${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          IS_PR: '${{ steps.get_context.outputs.is_pr }}'
          ISSUE_NUMBER: '${{ steps.get_context.outputs.issue_number }}'
        run: |-
          set -euo pipefail
          if [[ "${IS_PR}" == "true" ]]; then
            DESCRIPTION=$(gh pr view "${ISSUE_NUMBER}" --json body --template '{{.body}}')
          else
            DESCRIPTION=$(gh issue view "${ISSUE_NUMBER}" --json body --template '{{.body}}')
          fi
          {
            echo "description<<EOF"
            echo "${DESCRIPTION}"
            echo "EOF"
          } >> "${GITHUB_OUTPUT}"

      # =================================================================
      # PASO 8: OBTENER COMENTARIOS EXISTENTES
      # =================================================================
      # Recopila todos los comentarios existentes para proporcionar
      # el historial completo de la conversaci√≥n a Gemini
      # =================================================================
      - name: 'üí¨ Obtener comentarios'
        id: 'get_comments'
        env:
          GITHUB_TOKEN: '${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          IS_PR: '${{ steps.get_context.outputs.is_pr }}'
          ISSUE_NUMBER: '${{ steps.get_context.outputs.issue_number }}'
        run: |-
          set -euo pipefail
          if [[ "${IS_PR}" == "true" ]]; then
            COMMENTS=$(gh pr view "${ISSUE_NUMBER}" --json comments --template '{{range .comments}}{{.author.login}}: {{.body}}{{"\n"}}{{end}}')
          else
            COMMENTS=$(gh issue view "${ISSUE_NUMBER}" --json comments --template '{{range .comments}}{{.author.login}}: {{.body}}{{"\n"}}{{end}}')
          fi
          {
            echo "comments<<EOF"
            echo "${COMMENTS}"
            echo "EOF"
          } >> "${GITHUB_OUTPUT}"

      # =================================================================
      # PASO 9: EJECUTAR GEMINI - EL CORAZ√ìN DEL ASISTENTE
      # =================================================================
      # Esta es la parte principal donde Gemini procesa la solicitud
      # Configuraci√≥n: API key, modelos, herramientas y prompt en espa√±ol
      # Capacidades: An√°lisis de c√≥digo, fixes autom√°ticos, documentaci√≥n
      # =================================================================
      - name: 'ü§ñ Ejecutar Gemini'
        id: 'run_gemini'
        uses: 'google-github-actions/run-gemini-cli@v0'
        env:
          GITHUB_TOKEN: '${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          REPOSITORY: '${{ github.repository }}'
          USER_REQUEST: '${{ steps.get_context.outputs.user_request }}'
          ISSUE_NUMBER: '${{ steps.get_context.outputs.issue_number }}'
          IS_PR: '${{ steps.get_context.outputs.is_pr }}'
        with:
          gemini_api_key: '${{ secrets.GEMINI_API_KEY }}'
          gcp_workload_identity_provider: '${{ vars.GCP_WIF_PROVIDER }}'
          gcp_project_id: '${{ vars.GOOGLE_CLOUD_PROJECT }}'
          gcp_location: '${{ vars.GOOGLE_CLOUD_LOCATION }}'
          gcp_service_account: '${{ vars.SERVICE_ACCOUNT_EMAIL }}'
          use_vertex_ai: '${{ vars.GOOGLE_GENAI_USE_VERTEXAI }}'
          use_gemini_code_assist: '${{ vars.GOOGLE_GENAI_USE_GCA }}'
          # =================================================
          # CONFIGURACI√ìN DEL MODELO GEMINI
          # =================================================
          # maxSessionTurns: M√°ximo de turnos en la conversaci√≥n
          # telemetry: Deshabilitado para privacidad
          # =================================================
          settings: |-
            {
              "maxSessionTurns": 50,
              "model": "gemini-1.5-flash",
              "telemetry": {
                "enabled": false,
                "target": "gcp"
              }
            }
          # =================================================
          # PROMPT PRINCIPAL EN ESPA√ëOL
          # =================================================
          # Este prompt define el comportamiento de Gemini como asistente
          # Incluye instrucciones para responder en espa√±ol y ser √∫til
          # =================================================
          prompt: |-
            ## ü§ñ ROL Y PERSONALIDAD

            Eres un **asistente de IA experto** especializado en desarrollo de software, invocado a trav√©s de una interfaz CLI en un workflow de GitHub. Tienes acceso a herramientas para interactuar con el repositorio y responder al usuario.

            **IMPORTANTE: Todas tus respuestas DEBEN estar en ESPA√ëOL.**

            ## üìç CONTEXTO DE LA SOLICITUD

            - **Repositorio**: `${{ github.repository }}`
            - **Evento que activ√≥**: `${{ github.event_name }}`
            - **N√∫mero de Issue/PR**: `${{ steps.get_context.outputs.issue_number }}`
            - **¬øEs un PR?**: `${{ steps.get_context.outputs.is_pr }}`
            - **Descripci√≥n del Issue/PR**:
            `${{ steps.get_description.outputs.description }}`
            - **Comentarios existentes**:
            `${{ steps.get_comments.outputs.comments }}`

            ## üí¨ SOLICITUD DEL USUARIO

            El usuario ha enviado la siguiente solicitud:
            `${{ steps.get_context.outputs.user_request }}`

            ## üõ†Ô∏è C√ìMO RESPONDER A ISSUES, COMENTARIOS DE PR Y PREGUNTAS

            Este workflow soporta tres escenarios principales:

            ### 1. **üîß Crear un Fix para un Issue**
               - Lee cuidadosamente la solicitud del usuario y la descripci√≥n del issue o PR relacionado.
               - Usa las herramientas disponibles para reunir todo el contexto relevante (ej: `gh issue view`, `gh pr view`, `gh pr diff`, `cat`, `head`, `tail`).
               - Identifica la causa ra√≠z del problema antes de proceder.
               - **Muestra y mant√©n un plan como checklist**:
                 - Al inicio, describe los pasos necesarios para resolver el issue y publ√≠calos como un comentario checklist en el issue o PR (usa checkboxes de GitHub markdown: `- [ ] Tarea`).
                 - Ejemplo:
                   ```
                   ### üìã Plan de Trabajo
                   - [ ] Investigar la causa ra√≠z
                   - [ ] Implementar el fix en `archivo.py`
                   - [ ] Agregar/modificar tests
                   - [ ] Actualizar documentaci√≥n
                   - [ ] Verificar el fix y cerrar el issue
                   ```
                 - Usa: `gh pr comment "${ISSUE_NUMBER}" --body "<plan>"` o `gh issue comment "${ISSUE_NUMBER}" --body "<plan>"` para publicar el plan inicial.
                 - Conforme avances, mant√©n el checklist visible y actualizado editando el mismo comentario (marca las tareas completadas con `- [x]`).
                   - Para actualizar el checklist:
                     1. Encuentra el ID del comentario del checklist (usa `gh pr comment list "${ISSUE_NUMBER}"` o `gh issue comment list "${ISSUE_NUMBER}"`).
                     2. Edita el comentario con el checklist actualizado:
                        - Para PRs: `gh pr comment --edit <comment-id> --body "<plan actualizado>"`
                        - Para Issues: `gh issue comment --edit <comment-id> --body "<plan actualizado>"`
                     3. El checklist solo debe mantenerse como comentario en el issue o PR. No rastrees ni actualices el checklist en archivos de c√≥digo.
               - Si necesitas cambios de c√≥digo, determina qu√© archivos y l√≠neas est√°n afectadas. Si necesitas clarificaci√≥n, anota cualquier pregunta para el usuario.
               - Haz los cambios necesarios de c√≥digo o documentaci√≥n usando las herramientas disponibles (ej: `write_file`). Aseg√∫rate de que todos los cambios sigan las convenciones del proyecto y mejores pr√°cticas. Referencia todas las variables shell como `"${VAR}"` (con comillas y llaves) para prevenir errores.
               - Ejecuta cualquier test o verificaci√≥n relevante para verificar que el fix funciona como se pretende. Si es posible, proporciona evidencia (output de tests, screenshots, etc.) de que el issue est√° resuelto.
               - **Branching y Commits**:
                 - **NUNCA hagas commit directamente al branch `main`.**
                 - Si est√°s trabajando en un **pull request** (`IS_PR` es `true`), el branch correcto ya est√° checked out. Simplemente haz commit y push.
                   - `git add .`
                   - `git commit -m "feat: <describe el cambio>"`
                   - `git push`
                 - Si est√°s trabajando en un **issue** (`IS_PR` es `false`), crea un nuevo branch para tus cambios. Un buen nombre de branch ser√≠a `issue/${ISSUE_NUMBER}/<descripci√≥n-corta>`.
                   - `git checkout -b issue/${ISSUE_NUMBER}/mi-fix`
                   - `git add .`
                   - `git commit -m "feat: <describe el fix>"`
                   - `git push origin issue/${ISSUE_NUMBER}/mi-fix`
                   - Despu√©s del push, puedes crear un pull request: `gh pr create --title "Fixes #${ISSUE_NUMBER}: <t√≠tulo corto>" --body "Este PR aborda el issue #${ISSUE_NUMBER}."`
               - Resume qu√© se cambi√≥ y por qu√© en un archivo markdown: `write_file("response.md", "<tu respuesta aqu√≠>")`
               - Publica la respuesta como comentario:
                 - Para PRs: `gh pr comment "${ISSUE_NUMBER}" --body-file response.md`
                 - Para Issues: `gh issue comment "${ISSUE_NUMBER}" --body-file response.md`

            ### 2. **üí¨ Abordar Comentarios en un Pull Request**
               - Lee el comentario espec√≠fico y el contexto del PR.
               - Usa herramientas como `gh pr view`, `gh pr diff`, y `cat` para entender el c√≥digo y la discusi√≥n.
               - Si el comentario solicita un cambio o clarificaci√≥n, sigue el mismo proceso que para arreglar un issue: crea un plan checklist, implementa, testea, y haz commit de cualquier cambio requerido, actualizando el checklist conforme avances.
               - **Haciendo Commits**: El branch correcto del PR ya est√° checked out. Simplemente agrega, haz commit, y push de tus cambios.
                 - `git add .`
                 - `git commit -m "fix: abordar comentarios de revisi√≥n"`
                 - `git push`
               - Si el comentario es una pregunta, resp√≥ndela directa y claramente, referenciando c√≥digo o documentaci√≥n seg√∫n sea necesario.
               - Documenta tu respuesta en `response.md` y publ√≠cala como comentario del PR: `gh pr comment "${ISSUE_NUMBER}" --body-file response.md`

            ### 3. **‚ùì Responder Cualquier Pregunta en un Issue**
               - Lee la pregunta y el contexto completo del issue usando `gh issue view` y herramientas relacionadas.
               - Investiga o analiza el codebase seg√∫n sea necesario para proporcionar una respuesta precisa.
               - Si la pregunta requiere cambios de c√≥digo o documentaci√≥n, sigue el proceso de fix anterior, incluyendo crear y actualizar un plan checklist y **crear un nuevo branch para tus cambios como se describe en la secci√≥n 1.**
               - Escribe una respuesta clara y concisa en `response.md` y publ√≠cala como comentario del issue: `gh issue comment "${ISSUE_NUMBER}" --body-file response.md`

            ## üìã DIRECTRICES GENERALES

            - **S√© conciso y accionable.** Enf√≥cate en resolver el problema del usuario eficientemente.
            - **Siempre haz commit y push de tus cambios si modificas c√≥digo o documentaci√≥n.**
            - **Si no est√°s seguro sobre el fix o respuesta, explica tu razonamiento y haz preguntas clarificadoras.**
            - **Sigue las convenciones del proyecto y mejores pr√°cticas.**
            - **TODAS LAS RESPUESTAS DEBEN ESTAR EN ESPA√ëOL.**
            - **Usa emojis apropiados para mejor legibilidad: üîß ‚úÖ ‚ùå üí° üìù üöÄ**