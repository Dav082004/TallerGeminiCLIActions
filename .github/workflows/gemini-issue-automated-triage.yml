name: üè∑Ô∏è Gemini CLI - Clasificaci√≥n de Issues

# =============================================================
# WORKFLOW: Gemini CLI - Clasificaci√≥n de Issues
# =============================================================
# Este workflow utiliza Gemini CLI para analizar y clasificar issues autom√°ticamente.
#
# ¬øQu√© hace?
# - Detecta nuevos issues, comentarios con comandos especiales o ejecuciones manuales.
# - Analiza el contenido del issue y sugiere etiquetas, prioridad, complejidad y √°rea.
# - Comenta el an√°lisis y aplica etiquetas autom√°ticamente.
#
# Disparadores principales:
# - Cuando se crea, edita o reabre un issue.
# - Cuando se comenta en un issue usando @gemini-cli y el comando /triage.
# - Cuando se ejecuta manualmente desde la interfaz de GitHub (workflow_dispatch).
# =============================================================

on:
  issues:
    types: [opened, edited, reopened]
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      issue_number:
        description: "N√∫mero del issue o PR a clasificar"
        required: false
        type: string

jobs:
  triage:
    name: Clasificar Issue con Gemini
    runs-on: ubuntu-latest

    # ----------------------------------------------------------------------
    # CONDICI√ìN DE EJECUCI√ìN (if):
    # Solo ejecuta el job si se cumple al menos uno de estos casos:
    # 1. El workflow fue lanzado manualmente (workflow_dispatch)
    # 2. Se abri√≥ un nuevo issue (event_name == 'issues' && action == 'opened')
    # 3. Se coment√≥ en un issue, el comentario menciona a @gemini-cli y contiene /triage
    #    (event_name == 'issue_comment' && ...)
    # 4. Se coment√≥ en un PR, el comentario menciona a @gemini-cli y contiene /triage
    #    (event_name == 'pull_request_review_comment' && ...)
    # Esto evita ejecuciones innecesarias y asegura que solo act√∫e en los casos relevantes.
    # ----------------------------------------------------------------------
    if: >-
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issues' && github.event.action == 'opened') ||
      (github.event_name == 'issue_comment' && 
       github.event.issue != null &&
       contains(github.event.comment.body, '@gemini-cli') && 
       contains(github.event.comment.body, '/triage')) ||
      (github.event_name == 'pull_request_review_comment' && 
       contains(github.event.comment.body, '@gemini-cli') && 
       contains(github.event.comment.body, '/triage'))

    permissions:
      contents: read
      issues: write
      pull-requests: write

  # ----------------------------------------------------------------------
  # PERMISOS:
  # - contents:read        ‚Üí Permite leer archivos del repositorio si Gemini lo requiere para contexto.
  # - issues:write         ‚Üí Necesario para publicar comentarios y aplicar etiquetas al issue.
  # - pull-requests:write  ‚Üí Necesario para comentar en PRs cuando se use /triage en PRs.
  # ----------------------------------------------------------------------

    steps:
      - name: Obtener informaci√≥n del issue
        # -------------------------------------------------------------
        # Paso 1: Recopilar n√∫mero, t√≠tulo, cuerpo y URL del issue.
        # - Si el evento es 'issues', toma los datos directamente.
        # - Si es 'issue_comment' o 'workflow_dispatch', consulta el issue por API.
        # Esto permite que el workflow funcione tanto en triggers autom√°ticos como manuales.
        # -------------------------------------------------------------
        id: get-issue
        uses: actions/github-script@v7
        with:
          script: |
            let issueNumber;
            let issueData;
            
            if (context.eventName === 'issues') {
              // Issue creado directamente
              issueNumber = context.issue.number;
              issueData = context.payload.issue;
            } else if (context.eventName === 'issue_comment') {
              // Comentario en issue
              issueNumber = context.issue.number;
              const { data: issue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });
              issueData = issue;
            } else if (context.eventName === 'workflow_dispatch') {
              // Ejecuci√≥n manual
              issueNumber = context.payload.inputs.issue_number || context.issue.number;
              const { data: issue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });
              issueData = issue;
            }
            
            core.setOutput('issue_number', issueNumber);
            core.setOutput('issue_title', issueData.title);
            core.setOutput('issue_body', issueData.body);
            core.setOutput('issue_url', issueData.html_url);

      - name: Ejecutar Gemini CLI para Clasificaci√≥n
        # -------------------------------------------------------------
        # Paso 2: Enviar prompt a Gemini CLI con el t√≠tulo y cuerpo del issue.
        # El prompt explica a Gemini c√≥mo debe analizar y clasificar el issue.
        # Gemini responde con un an√°lisis estructurado y sugerencias.
        # -------------------------------------------------------------
        id: gemini-analysis
        uses: google-github-actions/run-gemini-cli@v0.1.10
        with:
          prompt: |
            Eres un experto en gesti√≥n de proyectos y clasificaci√≥n de issues de software.

            **ISSUE A ANALIZAR:**
            T√≠tulo: ${{ steps.get-issue.outputs.issue_title }}
            Descripci√≥n: ${{ steps.get-issue.outputs.issue_body }}

            Tu tarea es analizar el siguiente issue y:

            1. **Categorizar** el tipo de issue:
               - `bug` - Errores o fallos
               - `feature` - Nuevas funcionalidades
               - `enhancement` - Mejoras a funcionalidad existente
               - `documentation` - Relacionado con documentaci√≥n
               - `question` - Preguntas o consultas
               - `maintenance` - Tareas de mantenimiento
               - `security` - Problemas de seguridad

            2. **Determinar prioridad**:
               - `priority-critical` - Cr√≠tico, bloquea funcionalidad principal
               - `priority-high` - Alto, impacta usuarios importantes
               - `priority-medium` - Medio, mejora experiencia
               - `priority-low` - Bajo, mejora menor

            3. **Evaluar complejidad**:
               - `complexity-simple` - Soluci√≥n directa, pocas horas
               - `complexity-medium` - Requiere an√°lisis, d√≠as
               - `complexity-complex` - Cambios arquitect√≥nicos, semanas

            4. **Identificar √°rea**:
               - `area-frontend` - Interfaz de usuario
               - `area-backend` - L√≥gica del servidor
               - `area-database` - Base de datos
               - `area-api` - APIs y servicios
               - `area-devops` - Infraestructura y despliegue
               - `area-testing` - Pruebas y QA

            **Formato de respuesta**:

            ## üè∑Ô∏è Clasificaci√≥n Autom√°tica

            **Tipo**: [tipo]
            **Prioridad**: [prioridad]  
            **Complejidad**: [complejidad]
            **√Årea**: [√°rea]

            ## üìã An√°lisis

            [Breve explicaci√≥n del issue y raz√≥n de la clasificaci√≥n]

            ## üéØ Recomendaciones

            - [Sugerencia 1]
            - [Sugerencia 2]

            Responde siempre en espa√±ol y s√© espec√≠fico en tu an√°lisis.

          gemini_api_key: ${{ secrets.GEMINI_API_KEY }}

      - name: Comentar clasificaci√≥n en el issue
        # -------------------------------------------------------------
        # Paso 3: Si Gemini responde correctamente, comentar el an√°lisis en el issue
        # y aplicar etiquetas autom√°ticamente.
        # - Extrae patrones de la respuesta para convertirlos en labels.
        # - Aplica todas las etiquetas encontradas (tipo, prioridad, complejidad, √°rea).
        # -------------------------------------------------------------
        if: success()
        uses: actions/github-script@v7
        env:
          GEMINI_RESPONSE: ${{ steps.gemini-analysis.outputs.summary }}
        with:
          script: |
            const issueNumber = ${{ steps.get-issue.outputs.issue_number }};

            if (issueNumber) {
              const geminiResponse = process.env.GEMINI_RESPONSE || 'No se pudo obtener la respuesta de Gemini.';
              
              // Comentar la clasificaci√≥n
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `ü§ñ **Clasificaci√≥n Autom√°tica por Gemini CLI**\n\n${geminiResponse}`
              });
              
              // Extraer y aplicar labels autom√°ticamente
              const labels = [];
              
              // Buscar patrones de labels en la respuesta
              const typeMatch = geminiResponse.match(/\*\*Tipo\*\*:\s*`?([^`\n]*)`?/);
              const priorityMatch = geminiResponse.match(/\*\*Prioridad\*\*:\s*`?([^`\n]*)`?/);
              const complexityMatch = geminiResponse.match(/\*\*Complejidad\*\*:\s*`?([^`\n]*)`?/);
              const areaMatch = geminiResponse.match(/\*\*√Årea\*\*:\s*`?([^`\n]*)`?/);
              
              if (typeMatch) labels.push(typeMatch[1].trim());
              if (priorityMatch) labels.push(priorityMatch[1].trim());
              if (complexityMatch) labels.push(complexityMatch[1].trim());
              if (areaMatch) {
                // Manejar m√∫ltiples √°reas separadas por comas
                const areas = areaMatch[1].split(',').map(area => area.trim().replace(/`/g, ''));
                labels.push(...areas);
              }
              
              // Aplicar labels al issue
              if (labels.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: labels
                });
                
                console.log(`Labels aplicados: ${labels.join(', ')}`);
              }
            }

      - name: Comentar si hay error
        # -------------------------------------------------------------
        # Paso 4: Si ocurre un error en cualquier paso anterior, publica un comentario
        # en el issue con un mensaje de error y un enlace a los logs de la ejecuci√≥n.
        # -------------------------------------------------------------
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ steps.get-issue.outputs.issue_number }};
                              
            if (issueNumber) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: '‚ùå Error al clasificar el issue. [Ver logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})'
              });
            }
